#import "../stdlib"

module singleTrainOnlyFilterWithStatePattern;

class Train {
	int number;
}

active class Filter {
	Train latestTrain;
	control boolean enabled = false;
	
	// stark vereinfachter Signalpuffer (speichert nur das letzte Signal)
	control Object signal;
	
	actions {
		State initialState = new Checking(self);
		Transition initialTransition = new Transition(false, initialState);
		
		State currentState = initialTransition.nextState;
		Transition lastFired = initialTransition;
		
		while (currentState != null) {
			if (lastFired != null and !lastFired.internal) {
				currentState.enter();
			}
			
			lastFired = currentState.waitForEvent();
			if (lastFired != null) {
				currentState = lastFired.nextState;
			} else {
				currentState = null;
			}
		}
	}
	
	void send(Object newSignal) {
		signal = newSignal;
	}
	
	void publish() {
		SystemOut.println("published train at " + time);
	}
	
	void update(Train train) {
		SystemOut.println("received update at " + time);
		latestTrain = train;
	}
}

class Transition {
	boolean internal;
	State nextState;

	new(boolean internal, State nextState) {
		self.internal = internal;
		self.nextState = nextState;
	}
}

interface State {
	void enter();
	Transition waitForEvent();
}

class Checking implements State {
	Filter context;
	
	new(Filter context) {
		self.context = context;
	}
	
	void enter() {
	}
	
	Transition waitForEvent() {
		// Problem für Semantikdefinition da sich der Kontext von Ausdrücken ändert
		wait until !context.enabled or context.signal != null and context.signal instanceof Train;

		if (!context.enabled) {
			return new Transition(false, new Disabled(context));
		}
		if (context.signal != null and context.signal instanceof Train) {
			context.update(context.signal as Train);
			context.signal = null;
			return new Transition(false, new Filtering(context));
		}
		return null;
	}
}

class Filtering implements State {
	Filter context;
	Timer timer;
	
	new(Filter context) {
		self.context = context;
	}
	
	void enter() {
		timer = new Timer(6);
		activate timer;
	}
	
	Transition waitForEvent() {
		wait until timer.expired 
		  or context.signal != null and context.signal instanceof Train
		  or !context.enabled;
		
		// Aktionen
		if (timer.expired) {
			timer.expired = false;
			context.publish();
			return new Transition(false, new Checking(context));
		}
		if (context.signal != null and context.signal instanceof Train) {
			context.update(context.signal as Train);
			context.signal = null;
			return new Transition(true, self);
		}
		if (!context.enabled) {
			return new Transition(false, new Disabled(context));
		}
		return null;
	}	
}

class Disabled implements State {
	Filter context;
	
	new(Filter context) {
		self.context = context;
	}
	
	void enter() {
	}
	
	Transition waitForEvent() {
		wait until context.enabled;
		if (context.enabled) return new Transition(false, new Checking(context));
		return null;
	}
}

active class Timer {
	int duration;
	control boolean expired = false;
	
	new(int duration) {
		self.duration = duration;
	}
	
	actions {
		advance duration;
		expired = true;
	}
}

active class TrainArrival {
	Filter filter;
	
	actions {
		while (true) {
			advance 2;
			Train train = new Train();
			train.number = 2;
			filter.send(train);
		}
	}
}

void main() {
	Filter filter = new Filter();
	activate filter;
	
	TrainArrival arrival = new TrainArrival();
	activate arrival;
	arrival.filter = filter;
	
	advance 10;
	filter.enabled = true;

	advance 15;
	filter.enabled = false;

	// Modell dient zur Untersuchung des Systemverhaltens
	advance 	10;
}