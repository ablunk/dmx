#import "../../dbl"
#import "../../stdlib"

module ssm {

extension SendStatement extends dbl SimpleStatement {
	start SendStatementSyntax;
	SendStatementSyntax -> "send" signal:Expression "to" target:Expression ";";
}

semantics for SendStatement {
	expand "print \"sending\";";
	//expand target".eventPool.add("signal");";
	//expand "reactivate "target";";
}

extension StateMachine extends dbl ClassContentExtension {
	start StateMachineSyntax;
	StateMachineSyntax -> "stateMachine" "{" initialState:InitialState ManyRegularStates "}";
		
	ManyRegularStates -> ;
	ManyRegularStates -> states : list State ManyRegularStates;
	
	InitialState -> "initial" "->" target:$$State ";";
	State -> "state" name:ID Transitions ";";
	
	Transitions -> ;
	Transitions -> "(" OneOrMoreTransitions ")";
	
	OneOrMoreTransitions -> outgoingTransitions : list Transition MoreTransitions;
	MoreTransitions -> ;
	MoreTransitions -> "," OneOrMoreTransitions;

	Transition -> trigger:Trigger TargetState;
	
	// Trigger must extend LocalScopeStatement in order to access the variable in the body
	// this is a good reason for defining the metamodel seperate from the concrete syntax
	// or at least to have the flexibility to do so.
	// we could look for a DBL class with the name of the rule and check if this class extends a DBL metaclass.
	// if it does, we convert the DBL class to a metaclass and use it.
	Trigger -> "on" variable:Variable Effects;
	Trigger -> "after" duration:Duration Effects;
	Duration -> "(" value:Expression ")";
	Effects -> ;
	Effects -> "do" body : LocalScopeStatement;
		
	TargetState -> "->" target:$$State;
	TargetState -> "->" "final";
}

semantics for StateMachine {
	expand "
		actions {
			print \"executing actions\";
		}
	";
}

}