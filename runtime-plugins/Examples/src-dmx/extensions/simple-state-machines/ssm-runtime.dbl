#import "../../stdlib"
#import "../../dbl"

module ssmRuntime {

// dbx files cannot be imported at the moment.
// therefore, all runtime structures have to be placed in a dbl file :(

class Event {}
class Signal extends Event {}
class TimeEvent extends Event {}

active class ObjectWithStateMachine {
	StateMachineRuntime stateMachineRuntime;
	
	void sendSignal(Signal signal) {
		stateMachineRuntime.enterEvent(signal);
	}
	
	actions {
		print("running state machine\n");
		activate stateMachineRuntime;
	}
}

// syntax classes should be auto-generated by an extension from the syntax definition of an extension
class StateMachine {
	Object context;
	List states;
	State initialState;
	
	new() {
		self.states = new ArrayList;	
	}
}

class State {
	string name;
	List outgoingTransitions;
	
	new() {
		self.outgoingTransitions = new ArrayList;
	}
}

class Transition {
	State target;
	Variable messageVariable;
}

// TODO like in Java, each class should extend Object implicitly
// class must be placed before StateMachineRuntime because of the equals methods used there.
class CompiledState extends Object {
	State state;
	List compiledTransitions;
	List timers;
	
	new(State state) {
		self.state = state;
		self.compiledTransitions = new ArrayList();
		self.timers = new ArrayList();
	}
	
	void enter() {
		startTimers();
	}
	
	void startTimers() {
		for (int i=0; i<timers.size(); i=i+1) {
			Timer timer = timers.get(i) as Timer;
			timer.start();
		}
	}
	
	void leave() {
		cancelRunningTimers();
	}
	
	void cancelRunningTimers() {
		for (int i=0; i<timers.size(); i=i+1) {
			Timer timer = timers.get(i) as Timer;
			timer.cancel();
		}
	}
	
	void addTimer(Timer timer) {
		timers.add(timer);
	}
	
	void addCompiledTransition(CompiledTransition compiledTransition) {
		compiledTransitions.add(compiledTransition);
	}
	
	State consumeEvent(Event event, Object context) {
		print("consuming in event\n");
		for (int i=0; i<compiledTransitions.size(); i=i+1) {
			CompiledTransition compiledTransition = compiledTransitions.get(i) as CompiledTransition;
			
			if (compiledTransition.canHandle(event)) {
				print("executing effects\n");
				compiledTransition.executeEffects(context, event);
				compiledTransition.reset();
				
				Transition transition = compiledTransition.transition;
				return transition.target;
			}
		}
		return null;		
	}	
}

// runtime classes have to be defined manually as part of the semantics definition
active class StateMachineRuntime {
	StateMachine stateMachine;
	
	Map stateToCompiledState = new HashMap;
	List eventQueue = new ArrayList;
	CompiledState currentState;
	
	new(StateMachine stateMachine) {
		self.stateMachine = stateMachine;
	}
	
	void setCompiledState(State state, CompiledState compiledState) {
		stateToCompiledState.put(state, compiledState);
	}

	actions {
		currentState = stateToCompiledState.get(stateMachine.initialState) as CompiledState;
		executeEventLoop();
	}
	
	void executeEventLoop() {
		while (currentState != null and !eventQueue.isEmpty()) {
			print("current state = " + currentState.state.name + "\n");
			Event nextEvent = popNextEvent();
			State nextState = currentState.consumeEvent(nextEvent, stateMachine.context);
			if (nextState != null) {
				CompiledState compiledNextState = stateToCompiledState.get(nextState) as CompiledState;
				currentState = compiledNextState;
				if (currentState != compiledNextState) { // better use equals here
					currentState.leave();
				}
				currentState.enter();
				print("waiting\n");
				wait;
			} else {
				print("there is no next state. exiting.\n");
			}
		}
	}
	
	Event popNextEvent() {
		Event nextEvent = eventQueue.get(0) as Event;
		eventQueue.remove(nextEvent);
		return nextEvent;
	}
	
	void enterEvent(Event event) {
		eventQueue.add(event);
		reactivate self;
	}
}

class CompiledTransition {
	Transition transition;
	TimeEvent assignedFiredTimeEvent;
	
	new(Transition transition) {
		self.transition = transition;
	}
	
	boolean canHandle(Event event) {
		if (event instanceof Signal) {
			return canHandleSignal(event as Signal);
		} else if (event instanceof TimeEvent) {
			return event == assignedFiredTimeEvent;
		} else {
			return false;
		}
	}
	
	boolean canHandleSignal(Signal message) {
		return false;
	}
	
	void reset() {
		assignedFiredTimeEvent = null;
	}
	
	// to be overridden
	void executeEffects(Object context, Event event) {}
	
	// to be overridden
	int getTimeDuration() {
		return 0;
	}
}

active class Timer {
	StateMachineRuntime stateMachineRuntime;
	CompiledTransition compiledTransition;
	boolean cancelled = false;
	
	void start() {
		activate self;
	}
	
	void cancel() {
		cancelled = true;
	}
	
	actions {
		advance compiledTransition.getTimeDuration();
		if (!cancelled) {
			compiledTransition.assignedFiredTimeEvent = new TimeEvent();
			stateMachineRuntime.enterEvent(new TimeEvent());
		}
	}
}

}