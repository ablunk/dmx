#import "ssm-runtime"
#import "../../stdlib"

module baseSimplesystem;

class Data extends Signal {
	string payLoad;
	
	new(string payLoad) {
		self.payLoad = payLoad;
	}
}

class Delayer extends ObjectWithStateMachine {
	ObjectWithStateMachine receiver;
	Data lastReceived = null;
	
	StateMachineRuntime createStateMachineRuntime(Object context) {	
		StateMachine stateMachine = new StateMachine();
		stateMachine.context = context;
		StateMachineRuntime stateMachineRuntime = new StateMachineRuntime(stateMachine);
	
		State waiting = new State;
		stateMachine.states.add(waiting);
		waiting.name = "waiting";
		
		stateMachine.initialState = waiting;
		
		CompiledState compiledWaiting = new CompiledState(waiting);
		stateMachineRuntime.setCompiledState(waiting, compiledWaiting);
		
		Transition onData = new Transition;
		waiting.outgoingTransitions.add(onData);
		onData.target = waiting;
		
		compiledWaiting.addCompiledTransition(new OnDataTransition(onData));	
		
		return stateMachineRuntime;
	}
	
	void onDataEffects() {
		print("received data\n");
	}
}

void main() {
	Delayer delayer = new Delayer;
	activate delayer;
	advance 1;
	delayer.sendSignal(new Data("blob"));
	advance 10;
}

// structures below would be generated by an extension
class OnDataTransition extends CompiledTransition {

	new(Transition transition) {
		super(transition);
	}

	boolean canHandleSignal(Signal signal) {
		return signal instanceof Data; 
	}
	
	void executeEffects(Object context, Event event) {
		Delayer concreteContext = context as Delayer;
		concreteContext.onDataEffects();
	}
}