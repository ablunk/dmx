<?xml version="1.0" encoding="ASCII"?>
<dbl:Model xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dbl="http://www.informatik.hu-berlin.de/sam/dbl">
  <imports file="../../../stdx">
    <model href="../../../stdx.xmi#/"/>
  </imports>
  <imports file="../../../stdlib">
    <model href="../../../stdlib.xmi#/"/>
  </imports>
  <imports file="../ssm-runtime">
    <model href="../ssm-runtime.xmi#/"/>
  </imports>
  <module name="baseDelayerSystem">
    <classifiers xsi:type="dbl:Class" name="Data" concreteSyntax="class Data extends Signal {&#xA;&#x9;string payLoad;&#xA;&#x9;&#xA;&#x9;new(string payLoad) {&#xA;&#x9;&#x9;self.payLoad = payLoad;&#xA;&#x9;}&#xA;}">
      <attributes name="payLoad" concreteSyntax="string payLoad">
        <primitiveType xsi:type="dbl:StringType"/>
      </attributes>
      <constructors>
        <statements xsi:type="dbl:Assignment" concreteSyntax="self.payLoad = payLoad">
          <variable concreteSyntax="self.payLoad">
            <idExpr concreteSyntax="self.payLoad" referencedElement="//@module/@classifiers.0/@constructors.0/@parameters.0">
              <parentIdExpr concreteSyntax="self">
                <predefinedId xsi:type="dbl:MeLiteral"/>
              </parentIdExpr>
            </idExpr>
          </variable>
          <value xsi:type="dbl:IdExpr" concreteSyntax="payLoad" referencedElement="//@module/@classifiers.0/@constructors.0/@parameters.0"/>
        </statements>
        <parameters name="payLoad">
          <primitiveType xsi:type="dbl:StringType"/>
        </parameters>
      </constructors>
      <superClass href="../ssm-runtime.xmi#//@module/@classifiers.2"/>
    </classifiers>
    <classifiers xsi:type="dbl:ActiveClass" name="Delayer" concreteSyntax="active class Delayer implements SignalReceiver, EventConsumer {&#xA;&#x9;SignalReceiver dataConsumer;&#xA;&#x9;Data lastData = null;&#xA;&#x9;&#xA;&#x9;ControlList events = new ControlList;&#xA;&#x9;List timers = new ArrayList;&#xA;&#x9;&#xA;&#x9;Map stateById = new HashMap;&#xA;&#x9;State currentState;&#xA;&#x9;&#xA;&#x9;// zur Nachbildung eines wait until&#xA;&#x9;List objectsWaitingForChangesInEventsSize = new ArrayList;&#xA;&#x9;List objectsWaitingForChangesInDataConsumer = new ArrayList;&#xA;&#x9;&#xA;&#x9;Object message;&#xA;&#x9;&#xA;&#x9;actions {&#xA;&#x9;&#x9;State disconnected = new State;&#xA;&#x9;&#x9;disconnected.id = 0;&#xA;&#x9;&#x9;disconnected.name = &quot;disconnected&quot;;&#xA;&#x9;&#x9;stateById.put(disconnected.id, disconnected);&#xA;&#x9;&#x9;currentState = disconnected; // Initialzustand setzen&#xA;&#xA;&#x9;&#x9;State waiting = new State;&#xA;&#x9;&#x9;waiting.id = 1;&#xA;&#x9;&#x9;waiting.name = &quot;waiting&quot;; // wird hier nicht gebraucht, k&#xf6;nnte f&#xfc;r das Debugging aber n&#xfc;tzlich sein&#xA;&#x9;&#x9;stateById.put(waiting.id, waiting);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;eventLoop();&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;void sendSignal(Object signal) {&#xA;&#x9;&#x9;events.add(signal);&#xA;&#x9;&#x9;reactivateObjectsWaitingForChangesInEventsSize();&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;void enterEvent(Event event) {&#xA;&#x9;&#x9;events.add(event);&#xA;&#x9;&#x9;reactivateObjectsWaitingForChangesInEventsSize();&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;void reactivateObjectsWaitingForChangesInEventsSize() {&#xA;&#x9;&#x9;// Nachbildung der Reaktivierung von Objekten, die auf den Ausdruck in einer wait-until-Anweisung warten&#xA;&#x9;&#x9;for (int i=0; i&lt;objectsWaitingForChangesInEventsSize.size(); i=i+1) {&#xA;&#x9;&#x9;&#x9;reactivate objectsWaitingForChangesInEventsSize.get(0);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#x9;&#xA;&#x9;&#xA;&#x9;void eventLoop() {&#xA;&#x9;&#x9;while (currentState != null) {&#xA;&#x9;&#x9;&#x9;State nextState = enterStateById(currentState.id);&#xA;&#x9;&#x9;&#x9;currentState = nextState;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;State enterStateById(int stateId) {&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;string nextStateId = null;&#xA;&#x9;&#x9;switch (stateId) {&#xA;&#x9;&#x9;&#x9;case 0: // 0 -> disconnected&#xA;&#x9;&#x9;&#x9;&#x9;nextStateId = state0_wait();&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case 1: // 1 -> waiting&#xA;&#x9;&#x9;&#x9;&#x9;nextStateId = state1_wait();&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;cancelRunningTimers();&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;return nextStateId;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;void cancelRunningTimers() {&#xA;&#x9;&#x9;foreach (Timer timer in timers) {&#xA;&#x9;&#x9;&#x9;timer.cancel();&#xA;&#x9;&#x9;}&#xA;&#x9;}&#x9;&#xA;&#xA;&#x9;State state0_wait() {&#xA;&#x9;&#x9;wait until events.size > 0;&#xA;&#x9;&#xA;&#x9;&#x9;objectsWaitingForChangesInEventsSize.add(self);&#xA;&#x9;&#x9;objectsWaitingForChangesInDataConsumer.add(self);&#xA;&#x9;&#x9;while (! (events.size > 0 or dataConsumer == null)) {&#xA;&#x9;&#x9;&#x9;wait;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;objectsWaitingForChangesInEventsSize.remove(self);&#xA;&#x9;&#x9;objectsWaitingForChangesInDataConsumer.remove(self);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;// pr&#xfc;ft zuerst auf Signal- oder Zeitereignis&#xA;&#x9;&#x9;if (events.size > 0) {&#xA;&#x9;&#x9;&#x9;Object event = events.get(0);&#xA;&#x9;&#x9;&#x9;events.remove(event);&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;// pr&#xfc;ft danach auf Zustandsereignis&#xA;&#x9;&#x9;if (dataConsumer != null) {&#xA;&#x9;&#x9;&#x9;return stateById.get(1);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;// f&#xfc;r jeden Zustand gibt es eine spezifische wait-Methode mit einer wait-until-Anweisung,&#xA;&#x9;// die in ihrem Ausdruck die Bedingungen der ausgehenden Transitionen enth&#xe4;lt&#xA;&#x9;State state1_wait() {&#xA;&#x9;&#x9;// f&#xfc;r Transitionen, die auf Zeitereignisse warten, einen Timer starten&#xA;&#x9;&#x9;Timer timer0 = new Timer(0, time + 5, self);&#xA;&#x9;&#x9;timers.add(timer0);&#xA;&#x9;&#x9;timer0.start();&#xA;&#xA;&#x9;&#x9;wait until events.size > 0 or dataConsumer == null;&#xA;&#xA;&#x9;&#x9;// Die Semantik von wait-until ist nicht formal beschrieben. Deshalb wird das wait-until hier nachgebildet:&#xA;&#x9;&#x9;objectsWaitingForChangesInEventsSize.add(self);&#xA;&#x9;&#x9;objectsWaitingForChangesInDataConsumer.add(self);&#xA;&#x9;&#x9;while (! (events.size > 0 or dataConsumer == null)) {&#xA;&#x9;&#x9;&#x9;wait;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;objectsWaitingForChangesInEventsSize.remove(self);&#xA;&#x9;&#x9;objectsWaitingForChangesInDataConsumer.remove(self);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;// der Ausdruck in der Zustandsbedingung &quot;dataConsumer == null&quot; ist im Kontext von Delayer&#xA;&#x9;&#x9;// definiert und muss deshalb auch im Kontext von Delayer ausgewertet werden.&#xA;&#x9;&#x9;// Eine Auswertung innerhalb eines anderen Objektes erfordert&#xA;&#x9;&#x9;// a) ein Umschreiben des Ausdrucks auf einen anderen Kontext oder&#xA;&#x9;&#x9;// b) Funktionen mit einer Call-By-Name-Semantik, z.B. state1.waitUntil(events.size > 0 or dataConsumer == null)&#xA;&#x9;&#x9;// Beides ist in DBL nicht m&#xf6;glich. Deshalb kann der Ausdruck nur direkt im&#xA;&#x9;&#x9;// Kontext von Delayer eingesetzt werden.&#xA;&#x9;&#x9;// --> Erkenntnis: Dieses Problem des passendes Kontextes tritt immer bei Ausdr&#xfc;cken auf, die in einr&#xA;&#x9;&#x9;//     Erweiterung enthalten sind. Eine Unterst&#xfc;tzung in der Basissprache durch a) oder b)&#xA;&#x9;&#x9;//     ist deshalb sinnvoll.&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;// pr&#xfc;ft zuerst auf Signal- oder Zeitereignis&#xA;&#x9;&#x9;if (events.size > 0) {&#xA;&#x9;&#x9;&#x9;Object event = events.get(0);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Signal Data&#xA;&#x9;&#x9;&#x9;if (event instanceof Data) {&#xA;&#x9;&#x9;&#x9;&#x9;message = event;&#xA;&#x9;&#x9;&#x9;&#x9;state1_onDataTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;return stateById.get(1); // Folgezustand&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Zeitereignis&#xA;&#x9;&#x9;&#x9;if (event instanceof TimeEvent) {&#xA;&#x9;&#x9;&#x9;&#x9;TimeEvent timeEvent = event as TimeEvent;&#xA;&#x9;&#x9;&#x9;&#x9;if (timeEvent.associatedTransitionId == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;state1_afterTimeTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return stateById.get(1);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;// pr&#xfc;ft danach auf Zustandsereignis&#xA;&#x9;&#x9;if (dataConsumer == null) {&#xA;&#x9;&#x9;&#x9;return stateById.get(0);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;// f&#xfc;r den Effekt jeder Transition gibt es eine entsprechende Methode, die die Aktionen enth&#xe4;lt&#xA;&#x9;void state1_onDataTransition_effects() {&#xA;&#x9;&#x9;saveAsLastData(message as Data);&#xA;&#x9;}&#xA;&#xA;&#x9;void state1_afterTimeTransition_effects() {&#xA;&#x9;&#x9;forwardLastData();&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;void saveAsLastData(Data data) {&#xA;&#x9;&#x9;print &quot;received data with pay load: &quot; + data.payLoad;&#xA;&#x9;&#x9;lastData = data;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;void forwardLastData() {&#xA;&#x9;&#x9;print &quot;sending data with pay load: &quot; + lastData.payLoad;&#xA;&#x9;&#x9;dataConsumer.sendSignal(lastData);&#xA;&#x9;&#x9;lastData = null;&#xA;&#x9;}&#xA;}">
      <superInterfaces href="../ssm-runtime.xmi#//@module/@classifiers.3"/>
      <superInterfaces href="../ssm-runtime.xmi#//@module/@classifiers.1"/>
      <attributes name="dataConsumer" concreteSyntax="SignalReceiver dataConsumer">
        <classifierType concreteSyntax="SignalReceiver">
          <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.3"/>
        </classifierType>
      </attributes>
      <attributes name="lastData" concreteSyntax="Data lastData = null">
        <classifierType concreteSyntax="Data" referencedElement="//@module/@classifiers.0"/>
        <initialValue xsi:type="dbl:NullLiteral" concreteSyntax="null"/>
      </attributes>
      <attributes name="events" concreteSyntax="ControlList events = new ControlList">
        <classifierType concreteSyntax="ControlList">
          <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.5"/>
        </classifierType>
        <initialValue xsi:type="dbl:CreateObject" concreteSyntax="new ControlList">
          <classifierType concreteSyntax="ControlList">
            <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.5"/>
          </classifierType>
        </initialValue>
      </attributes>
      <attributes name="timers" concreteSyntax="List timers = new ArrayList">
        <classifierType concreteSyntax="List">
          <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5"/>
        </classifierType>
        <initialValue xsi:type="dbl:CreateObject" concreteSyntax="new ArrayList">
          <classifierType concreteSyntax="ArrayList">
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.6"/>
          </classifierType>
        </initialValue>
      </attributes>
      <attributes name="stateById" concreteSyntax="Map stateById = new HashMap">
        <classifierType concreteSyntax="Map">
          <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.7"/>
        </classifierType>
        <initialValue xsi:type="dbl:CreateObject" concreteSyntax="new HashMap">
          <classifierType concreteSyntax="HashMap">
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.8"/>
          </classifierType>
        </initialValue>
      </attributes>
      <attributes name="currentState" concreteSyntax="State currentState">
        <classifierType concreteSyntax="State">
          <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4"/>
        </classifierType>
      </attributes>
      <attributes name="objectsWaitingForChangesInEventsSize" concreteSyntax="List objectsWaitingForChangesInEventsSize = new ArrayList">
        <classifierType concreteSyntax="List">
          <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5"/>
        </classifierType>
        <initialValue xsi:type="dbl:CreateObject" concreteSyntax="new ArrayList">
          <classifierType concreteSyntax="ArrayList">
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.6"/>
          </classifierType>
        </initialValue>
      </attributes>
      <attributes name="objectsWaitingForChangesInDataConsumer" concreteSyntax="List objectsWaitingForChangesInDataConsumer = new ArrayList">
        <classifierType concreteSyntax="List">
          <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5"/>
        </classifierType>
        <initialValue xsi:type="dbl:CreateObject" concreteSyntax="new ArrayList">
          <classifierType concreteSyntax="ArrayList">
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.6"/>
          </classifierType>
        </initialValue>
      </attributes>
      <attributes name="message" concreteSyntax="Object message">
        <classifierType concreteSyntax="Object">
          <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.1"/>
        </classifierType>
      </attributes>
      <methods name="sendSignal">
        <primitiveType xsi:type="dbl:VoidType"/>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="events.add(signal)">
          <callIdExpr concreteSyntax="events.add(signal)">
            <parentIdExpr concreteSyntax="events" referencedElement="//@module/@classifiers.1/@attributes.2"/>
            <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.5/@methods.0"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="signal" referencedElement="//@module/@classifiers.1/@methods.0/@parameters.0"/>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="reactivateObjectsWaitingForChangesInEventsSize()">
          <callIdExpr concreteSyntax="reactivateObjectsWaitingForChangesInEventsSize()" referencedElement="//@module/@classifiers.1/@methods.2">
            <callPart/>
          </callIdExpr>
        </statements>
        <parameters name="signal">
          <classifierType concreteSyntax="Object">
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.1"/>
          </classifierType>
        </parameters>
      </methods>
      <methods name="enterEvent">
        <primitiveType xsi:type="dbl:VoidType"/>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="events.add(event)">
          <callIdExpr concreteSyntax="events.add(event)">
            <parentIdExpr concreteSyntax="events" referencedElement="//@module/@classifiers.1/@attributes.2"/>
            <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.5/@methods.0"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="event" referencedElement="//@module/@classifiers.1/@methods.1/@parameters.0"/>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="reactivateObjectsWaitingForChangesInEventsSize()">
          <callIdExpr concreteSyntax="reactivateObjectsWaitingForChangesInEventsSize()" referencedElement="//@module/@classifiers.1/@methods.2">
            <callPart/>
          </callIdExpr>
        </statements>
        <parameters name="event">
          <classifierType concreteSyntax="Event">
            <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.0"/>
          </classifierType>
        </parameters>
      </methods>
      <methods name="reactivateObjectsWaitingForChangesInEventsSize">
        <primitiveType xsi:type="dbl:VoidType"/>
        <statements xsi:type="dbl:ForStatement" concreteSyntax="for (int i=0; i&lt;objectsWaitingForChangesInEventsSize.size(); i=i+1) {&#xA;&#x9;&#x9;&#x9;reactivate objectsWaitingForChangesInEventsSize.get(0);&#xA;&#x9;&#x9;}">
          <statements xsi:type="dbl:Variable" name="i" concreteSyntax="int i=0">
            <primitiveType xsi:type="dbl:IntType"/>
            <initialValue xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
          </statements>
          <termination xsi:type="dbl:Less" concreteSyntax="i&lt;objectsWaitingForChangesInEventsSize.size()">
            <op1 xsi:type="dbl:IdExpr" concreteSyntax="i" referencedElement="//@module/@classifiers.1/@methods.2/@statements.0/@statements.0"/>
            <op2 xsi:type="dbl:IdExpr" concreteSyntax="objectsWaitingForChangesInEventsSize.size()">
              <parentIdExpr concreteSyntax="objectsWaitingForChangesInEventsSize" referencedElement="//@module/@classifiers.1/@attributes.6"/>
              <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.4"/>
              <callPart/>
            </op2>
          </termination>
          <increment concreteSyntax="i=i+1">
            <variable concreteSyntax="i">
              <idExpr concreteSyntax="i" referencedElement="//@module/@classifiers.1/@methods.2/@statements.0/@statements.0"/>
            </variable>
            <value xsi:type="dbl:Plus" concreteSyntax="i+1">
              <op1 xsi:type="dbl:IdExpr" concreteSyntax="i" referencedElement="//@module/@classifiers.1/@methods.2/@statements.0/@statements.0"/>
              <op2 xsi:type="dbl:IntLiteral" concreteSyntax="1" value="1"/>
            </value>
          </increment>
          <body xsi:type="dbl:LocalScopeStatement" concreteSyntax="{&#xA;&#x9;&#x9;&#x9;reactivate objectsWaitingForChangesInEventsSize.get(0);&#xA;&#x9;&#x9;}">
            <statements xsi:type="dbl:Reactivate" concreteSyntax="reactivate objectsWaitingForChangesInEventsSize.get(0)">
              <objectAccess xsi:type="dbl:IdExpr" concreteSyntax="objectsWaitingForChangesInEventsSize.get(0)">
                <parentIdExpr concreteSyntax="objectsWaitingForChangesInEventsSize" referencedElement="//@module/@classifiers.1/@attributes.6"/>
                <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.5"/>
                <callPart>
                  <callArguments xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
                </callPart>
              </objectAccess>
            </statements>
          </body>
        </statements>
      </methods>
      <methods name="eventLoop">
        <primitiveType xsi:type="dbl:VoidType"/>
        <statements xsi:type="dbl:WhileStatement" concreteSyntax="while (currentState != null) {&#xA;&#x9;&#x9;&#x9;State nextState = enterStateById(currentState.id);&#xA;&#x9;&#x9;&#x9;currentState = nextState;&#xA;&#x9;&#x9;}">
          <condition xsi:type="dbl:NotEqual" concreteSyntax="currentState != null">
            <op1 xsi:type="dbl:IdExpr" concreteSyntax="currentState" referencedElement="//@module/@classifiers.1/@attributes.5"/>
            <op2 xsi:type="dbl:NullLiteral" concreteSyntax="null"/>
          </condition>
          <body xsi:type="dbl:LocalScopeStatement" concreteSyntax="{&#xA;&#x9;&#x9;&#x9;State nextState = enterStateById(currentState.id);&#xA;&#x9;&#x9;&#x9;currentState = nextState;&#xA;&#x9;&#x9;}">
            <statements xsi:type="dbl:Variable" name="nextState" concreteSyntax="State nextState = enterStateById(currentState.id)">
              <classifierType concreteSyntax="State">
                <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4"/>
              </classifierType>
              <initialValue xsi:type="dbl:IdExpr" concreteSyntax="enterStateById(currentState.id)" referencedElement="//@module/@classifiers.1/@methods.4">
                <callPart>
                  <callArguments xsi:type="dbl:IdExpr" concreteSyntax="currentState.id">
                    <parentIdExpr concreteSyntax="currentState" referencedElement="//@module/@classifiers.1/@attributes.5"/>
                    <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4/@attributes.0"/>
                  </callArguments>
                </callPart>
              </initialValue>
            </statements>
            <statements xsi:type="dbl:Assignment" concreteSyntax="currentState = nextState">
              <variable concreteSyntax="currentState">
                <idExpr concreteSyntax="currentState" referencedElement="//@module/@classifiers.1/@attributes.5"/>
              </variable>
              <value xsi:type="dbl:IdExpr" concreteSyntax="nextState" referencedElement="//@module/@classifiers.1/@methods.3/@statements.0/@body/@statements.0"/>
            </statements>
          </body>
        </statements>
      </methods>
      <methods name="enterStateById">
        <classifierType concreteSyntax="State">
          <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4"/>
        </classifierType>
        <statements xsi:type="dbl:Variable" name="nextStateId" concreteSyntax="string nextStateId = null">
          <primitiveType xsi:type="dbl:StringType"/>
          <initialValue xsi:type="dbl:NullLiteral" concreteSyntax="null"/>
        </statements>
        <statements xsi:type="dbl:SwitchStatement" concreteSyntax="switch (stateId) {&#xA;&#x9;&#x9;&#x9;case 0: // 0 -> disconnected&#xA;&#x9;&#x9;&#x9;&#x9;nextStateId = state0_wait();&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case 1: // 1 -> waiting&#xA;&#x9;&#x9;&#x9;&#x9;nextStateId = state1_wait();&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}">
          <variable concreteSyntax="stateId">
            <idExpr concreteSyntax="stateId" referencedElement="//@module/@classifiers.1/@methods.4/@parameters.0"/>
          </variable>
          <cases>
            <value xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
            <body xsi:type="dbl:Assignment" concreteSyntax="nextStateId = state0_wait()">
              <variable concreteSyntax="nextStateId">
                <idExpr concreteSyntax="nextStateId" referencedElement="//@module/@classifiers.1/@methods.4/@statements.0"/>
              </variable>
              <value xsi:type="dbl:IdExpr" concreteSyntax="state0_wait()" referencedElement="//@module/@classifiers.1/@methods.6">
                <callPart/>
              </value>
            </body>
            <body xsi:type="dbl:BreakStatement" concreteSyntax="break"/>
          </cases>
          <cases>
            <value xsi:type="dbl:IntLiteral" concreteSyntax="1" value="1"/>
            <body xsi:type="dbl:Assignment" concreteSyntax="nextStateId = state1_wait()">
              <variable concreteSyntax="nextStateId">
                <idExpr concreteSyntax="nextStateId" referencedElement="//@module/@classifiers.1/@methods.4/@statements.0"/>
              </variable>
              <value xsi:type="dbl:IdExpr" concreteSyntax="state1_wait()" referencedElement="//@module/@classifiers.1/@methods.7">
                <callPart/>
              </value>
            </body>
            <body xsi:type="dbl:BreakStatement" concreteSyntax="break"/>
          </cases>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="cancelRunningTimers()">
          <callIdExpr concreteSyntax="cancelRunningTimers()" referencedElement="//@module/@classifiers.1/@methods.5">
            <callPart/>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:Return" concreteSyntax="return nextStateId">
          <value xsi:type="dbl:IdExpr" concreteSyntax="nextStateId" referencedElement="//@module/@classifiers.1/@methods.4/@statements.0"/>
        </statements>
        <parameters name="stateId">
          <primitiveType xsi:type="dbl:IntType"/>
        </parameters>
      </methods>
      <methods name="cancelRunningTimers">
        <primitiveType xsi:type="dbl:VoidType"/>
        <statements xsi:type="dbl:ForEach_ForEach_extension" concreteSyntax="foreach (Timer timer in timers) {&#xA;&#x9;&#x9;&#x9;timer.cancel();&#xA;&#x9;&#x9;}" instanceOfExtensionDefinition="true">
          <statements xsi:type="dbl:Variable" name="timer" concreteSyntax="Timer timer">
            <classifierType concreteSyntax="Timer">
              <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.7"/>
            </classifierType>
          </statements>
          <collection xsi:type="dbl:IdExpr" concreteSyntax="timers" referencedElement="//@module/@classifiers.1/@attributes.3"/>
          <body concreteSyntax="{&#xA;&#x9;&#x9;&#x9;timer.cancel();&#xA;&#x9;&#x9;}">
            <statements xsi:type="dbl:FunctionCall" concreteSyntax="timer.cancel()">
              <callIdExpr concreteSyntax="timer.cancel()">
                <parentIdExpr concreteSyntax="timer" referencedElement="//@module/@classifiers.1/@methods.5/@statements.0/@statements.0"/>
                <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.7/@methods.1"/>
                <callPart/>
              </callIdExpr>
            </statements>
          </body>
        </statements>
      </methods>
      <methods name="state0_wait">
        <classifierType concreteSyntax="State">
          <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4"/>
        </classifierType>
        <statements xsi:type="dbl:WaitUntil" concreteSyntax="wait until events.size > 0">
          <condition xsi:type="dbl:Greater" concreteSyntax="events.size > 0">
            <op1 xsi:type="dbl:IdExpr" concreteSyntax="events.size">
              <parentIdExpr concreteSyntax="events" referencedElement="//@module/@classifiers.1/@attributes.2"/>
              <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.5/@attributes.1"/>
            </op1>
            <op2 xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
          </condition>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="objectsWaitingForChangesInEventsSize.add(self)">
          <callIdExpr concreteSyntax="objectsWaitingForChangesInEventsSize.add(self)">
            <parentIdExpr concreteSyntax="objectsWaitingForChangesInEventsSize" referencedElement="//@module/@classifiers.1/@attributes.6"/>
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.0"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="self">
                <predefinedId xsi:type="dbl:MeLiteral"/>
              </callArguments>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="objectsWaitingForChangesInDataConsumer.add(self)">
          <callIdExpr concreteSyntax="objectsWaitingForChangesInDataConsumer.add(self)">
            <parentIdExpr concreteSyntax="objectsWaitingForChangesInDataConsumer" referencedElement="//@module/@classifiers.1/@attributes.7"/>
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.0"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="self">
                <predefinedId xsi:type="dbl:MeLiteral"/>
              </callArguments>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:WhileStatement" concreteSyntax="while (! (events.size > 0 or dataConsumer == null)) {&#xA;&#x9;&#x9;&#x9;wait;&#xA;&#x9;&#x9;}">
          <condition xsi:type="dbl:Not" concreteSyntax="! (events.size > 0 or dataConsumer == null)">
            <op xsi:type="dbl:Or" concreteSyntax="events.size > 0 or dataConsumer == null">
              <op1 xsi:type="dbl:Greater" concreteSyntax="events.size > 0">
                <op1 xsi:type="dbl:IdExpr" concreteSyntax="events.size">
                  <parentIdExpr concreteSyntax="events" referencedElement="//@module/@classifiers.1/@attributes.2"/>
                  <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.5/@attributes.1"/>
                </op1>
                <op2 xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
              </op1>
              <op2 xsi:type="dbl:Equal" concreteSyntax="dataConsumer == null">
                <op1 xsi:type="dbl:IdExpr" concreteSyntax="dataConsumer" referencedElement="//@module/@classifiers.1/@attributes.0"/>
                <op2 xsi:type="dbl:NullLiteral" concreteSyntax="null"/>
              </op2>
            </op>
          </condition>
          <body xsi:type="dbl:LocalScopeStatement" concreteSyntax="{&#xA;&#x9;&#x9;&#x9;wait;&#xA;&#x9;&#x9;}">
            <statements xsi:type="dbl:Wait" concreteSyntax="wait"/>
          </body>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="objectsWaitingForChangesInEventsSize.remove(self)">
          <callIdExpr concreteSyntax="objectsWaitingForChangesInEventsSize.remove(self)">
            <parentIdExpr concreteSyntax="objectsWaitingForChangesInEventsSize" referencedElement="//@module/@classifiers.1/@attributes.6"/>
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.8"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="self">
                <predefinedId xsi:type="dbl:MeLiteral"/>
              </callArguments>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="objectsWaitingForChangesInDataConsumer.remove(self)">
          <callIdExpr concreteSyntax="objectsWaitingForChangesInDataConsumer.remove(self)">
            <parentIdExpr concreteSyntax="objectsWaitingForChangesInDataConsumer" referencedElement="//@module/@classifiers.1/@attributes.7"/>
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.8"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="self">
                <predefinedId xsi:type="dbl:MeLiteral"/>
              </callArguments>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:IfStatement" concreteSyntax="if (events.size > 0) {&#xA;&#x9;&#x9;&#x9;Object event = events.get(0);&#xA;&#x9;&#x9;&#x9;events.remove(event);&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}">
          <condition xsi:type="dbl:Greater" concreteSyntax="events.size > 0">
            <op1 xsi:type="dbl:IdExpr" concreteSyntax="events.size">
              <parentIdExpr concreteSyntax="events" referencedElement="//@module/@classifiers.1/@attributes.2"/>
              <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.5/@attributes.1"/>
            </op1>
            <op2 xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
          </condition>
          <trueCase xsi:type="dbl:LocalScopeStatement" concreteSyntax="{&#xA;&#x9;&#x9;&#x9;Object event = events.get(0);&#xA;&#x9;&#x9;&#x9;events.remove(event);&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}">
            <statements xsi:type="dbl:Variable" name="event" concreteSyntax="Object event = events.get(0)">
              <classifierType concreteSyntax="Object">
                <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.1"/>
              </classifierType>
              <initialValue xsi:type="dbl:IdExpr" concreteSyntax="events.get(0)">
                <parentIdExpr concreteSyntax="events" referencedElement="//@module/@classifiers.1/@attributes.2"/>
                <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.5"/>
                <callPart>
                  <callArguments xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
                </callPart>
              </initialValue>
            </statements>
            <statements xsi:type="dbl:FunctionCall" concreteSyntax="events.remove(event)">
              <callIdExpr concreteSyntax="events.remove(event)">
                <parentIdExpr concreteSyntax="events" referencedElement="//@module/@classifiers.1/@attributes.2"/>
                <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.5/@methods.1"/>
                <callPart>
                  <callArguments xsi:type="dbl:IdExpr" concreteSyntax="event" referencedElement="//@module/@classifiers.1/@methods.6/@statements.6/@trueCase/@statements.0"/>
                </callPart>
              </callIdExpr>
            </statements>
          </trueCase>
        </statements>
        <statements xsi:type="dbl:IfStatement" concreteSyntax="if (dataConsumer != null) {&#xA;&#x9;&#x9;&#x9;return stateById.get(1);&#xA;&#x9;&#x9;}">
          <condition xsi:type="dbl:NotEqual" concreteSyntax="dataConsumer != null">
            <op1 xsi:type="dbl:IdExpr" concreteSyntax="dataConsumer" referencedElement="//@module/@classifiers.1/@attributes.0"/>
            <op2 xsi:type="dbl:NullLiteral" concreteSyntax="null"/>
          </condition>
          <trueCase xsi:type="dbl:LocalScopeStatement" concreteSyntax="{&#xA;&#x9;&#x9;&#x9;return stateById.get(1);&#xA;&#x9;&#x9;}">
            <statements xsi:type="dbl:Return" concreteSyntax="return stateById.get(1)">
              <value xsi:type="dbl:IdExpr" concreteSyntax="stateById.get(1)">
                <parentIdExpr concreteSyntax="stateById" referencedElement="//@module/@classifiers.1/@attributes.4"/>
                <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.7/@methods.0"/>
                <callPart>
                  <callArguments xsi:type="dbl:IntLiteral" concreteSyntax="1" value="1"/>
                </callPart>
              </value>
            </statements>
          </trueCase>
        </statements>
        <statements xsi:type="dbl:Return" concreteSyntax="return null">
          <value xsi:type="dbl:NullLiteral" concreteSyntax="null"/>
        </statements>
      </methods>
      <methods name="state1_wait">
        <classifierType concreteSyntax="State">
          <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4"/>
        </classifierType>
        <statements xsi:type="dbl:Variable" name="timer0" concreteSyntax="Timer timer0 = new Timer(0, time + 5, self)">
          <classifierType concreteSyntax="Timer">
            <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.7"/>
          </classifierType>
          <initialValue xsi:type="dbl:CreateObject" concreteSyntax="new Timer(0, time + 5, self)">
            <classifierType concreteSyntax="Timer(0, time + 5, self)">
              <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.7"/>
              <callPart>
                <callArguments xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
                <callArguments xsi:type="dbl:Plus" concreteSyntax="time + 5">
                  <op1 xsi:type="dbl:TimeLiteral" concreteSyntax="time"/>
                  <op2 xsi:type="dbl:IntLiteral" concreteSyntax="5" value="5"/>
                </callArguments>
                <callArguments xsi:type="dbl:IdExpr" concreteSyntax="self">
                  <predefinedId xsi:type="dbl:MeLiteral"/>
                </callArguments>
              </callPart>
            </classifierType>
          </initialValue>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="timers.add(timer0)">
          <callIdExpr concreteSyntax="timers.add(timer0)">
            <parentIdExpr concreteSyntax="timers" referencedElement="//@module/@classifiers.1/@attributes.3"/>
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.0"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="timer0" referencedElement="//@module/@classifiers.1/@methods.7/@statements.0"/>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="timer0.start()">
          <callIdExpr concreteSyntax="timer0.start()">
            <parentIdExpr concreteSyntax="timer0" referencedElement="//@module/@classifiers.1/@methods.7/@statements.0"/>
            <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.7/@methods.0"/>
            <callPart/>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:WaitUntil" concreteSyntax="wait until events.size > 0 or dataConsumer == null">
          <condition xsi:type="dbl:Or" concreteSyntax="events.size > 0 or dataConsumer == null">
            <op1 xsi:type="dbl:Greater" concreteSyntax="events.size > 0">
              <op1 xsi:type="dbl:IdExpr" concreteSyntax="events.size">
                <parentIdExpr concreteSyntax="events" referencedElement="//@module/@classifiers.1/@attributes.2"/>
                <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.5/@attributes.1"/>
              </op1>
              <op2 xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
            </op1>
            <op2 xsi:type="dbl:Equal" concreteSyntax="dataConsumer == null">
              <op1 xsi:type="dbl:IdExpr" concreteSyntax="dataConsumer" referencedElement="//@module/@classifiers.1/@attributes.0"/>
              <op2 xsi:type="dbl:NullLiteral" concreteSyntax="null"/>
            </op2>
          </condition>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="objectsWaitingForChangesInEventsSize.add(self)">
          <callIdExpr concreteSyntax="objectsWaitingForChangesInEventsSize.add(self)">
            <parentIdExpr concreteSyntax="objectsWaitingForChangesInEventsSize" referencedElement="//@module/@classifiers.1/@attributes.6"/>
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.0"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="self">
                <predefinedId xsi:type="dbl:MeLiteral"/>
              </callArguments>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="objectsWaitingForChangesInDataConsumer.add(self)">
          <callIdExpr concreteSyntax="objectsWaitingForChangesInDataConsumer.add(self)">
            <parentIdExpr concreteSyntax="objectsWaitingForChangesInDataConsumer" referencedElement="//@module/@classifiers.1/@attributes.7"/>
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.0"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="self">
                <predefinedId xsi:type="dbl:MeLiteral"/>
              </callArguments>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:WhileStatement" concreteSyntax="while (! (events.size > 0 or dataConsumer == null)) {&#xA;&#x9;&#x9;&#x9;wait;&#xA;&#x9;&#x9;}">
          <condition xsi:type="dbl:Not" concreteSyntax="! (events.size > 0 or dataConsumer == null)">
            <op xsi:type="dbl:Or" concreteSyntax="events.size > 0 or dataConsumer == null">
              <op1 xsi:type="dbl:Greater" concreteSyntax="events.size > 0">
                <op1 xsi:type="dbl:IdExpr" concreteSyntax="events.size">
                  <parentIdExpr concreteSyntax="events" referencedElement="//@module/@classifiers.1/@attributes.2"/>
                  <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.5/@attributes.1"/>
                </op1>
                <op2 xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
              </op1>
              <op2 xsi:type="dbl:Equal" concreteSyntax="dataConsumer == null">
                <op1 xsi:type="dbl:IdExpr" concreteSyntax="dataConsumer" referencedElement="//@module/@classifiers.1/@attributes.0"/>
                <op2 xsi:type="dbl:NullLiteral" concreteSyntax="null"/>
              </op2>
            </op>
          </condition>
          <body xsi:type="dbl:LocalScopeStatement" concreteSyntax="{&#xA;&#x9;&#x9;&#x9;wait;&#xA;&#x9;&#x9;}">
            <statements xsi:type="dbl:Wait" concreteSyntax="wait"/>
          </body>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="objectsWaitingForChangesInEventsSize.remove(self)">
          <callIdExpr concreteSyntax="objectsWaitingForChangesInEventsSize.remove(self)">
            <parentIdExpr concreteSyntax="objectsWaitingForChangesInEventsSize" referencedElement="//@module/@classifiers.1/@attributes.6"/>
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.8"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="self">
                <predefinedId xsi:type="dbl:MeLiteral"/>
              </callArguments>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="objectsWaitingForChangesInDataConsumer.remove(self)">
          <callIdExpr concreteSyntax="objectsWaitingForChangesInDataConsumer.remove(self)">
            <parentIdExpr concreteSyntax="objectsWaitingForChangesInDataConsumer" referencedElement="//@module/@classifiers.1/@attributes.7"/>
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.8"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="self">
                <predefinedId xsi:type="dbl:MeLiteral"/>
              </callArguments>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:IfStatement" concreteSyntax="if (events.size > 0) {&#xA;&#x9;&#x9;&#x9;Object event = events.get(0);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Signal Data&#xA;&#x9;&#x9;&#x9;if (event instanceof Data) {&#xA;&#x9;&#x9;&#x9;&#x9;message = event;&#xA;&#x9;&#x9;&#x9;&#x9;state1_onDataTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;return stateById.get(1); // Folgezustand&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Zeitereignis&#xA;&#x9;&#x9;&#x9;if (event instanceof TimeEvent) {&#xA;&#x9;&#x9;&#x9;&#x9;TimeEvent timeEvent = event as TimeEvent;&#xA;&#x9;&#x9;&#x9;&#x9;if (timeEvent.associatedTransitionId == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;state1_afterTimeTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return stateById.get(1);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}">
          <condition xsi:type="dbl:Greater" concreteSyntax="events.size > 0">
            <op1 xsi:type="dbl:IdExpr" concreteSyntax="events.size">
              <parentIdExpr concreteSyntax="events" referencedElement="//@module/@classifiers.1/@attributes.2"/>
              <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.5/@attributes.1"/>
            </op1>
            <op2 xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
          </condition>
          <trueCase xsi:type="dbl:LocalScopeStatement" concreteSyntax="{&#xA;&#x9;&#x9;&#x9;Object event = events.get(0);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Signal Data&#xA;&#x9;&#x9;&#x9;if (event instanceof Data) {&#xA;&#x9;&#x9;&#x9;&#x9;message = event;&#xA;&#x9;&#x9;&#x9;&#x9;state1_onDataTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;return stateById.get(1); // Folgezustand&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Zeitereignis&#xA;&#x9;&#x9;&#x9;if (event instanceof TimeEvent) {&#xA;&#x9;&#x9;&#x9;&#x9;TimeEvent timeEvent = event as TimeEvent;&#xA;&#x9;&#x9;&#x9;&#x9;if (timeEvent.associatedTransitionId == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;state1_afterTimeTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return stateById.get(1);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}">
            <statements xsi:type="dbl:Variable" name="event" concreteSyntax="Object event = events.get(0)">
              <classifierType concreteSyntax="Object">
                <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.1"/>
              </classifierType>
              <initialValue xsi:type="dbl:IdExpr" concreteSyntax="events.get(0)">
                <parentIdExpr concreteSyntax="events" referencedElement="//@module/@classifiers.1/@attributes.2"/>
                <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.5/@methods.5"/>
                <callPart>
                  <callArguments xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
                </callPart>
              </initialValue>
            </statements>
            <statements xsi:type="dbl:IfStatement" concreteSyntax="if (event instanceof Data) {&#xA;&#x9;&#x9;&#x9;&#x9;message = event;&#xA;&#x9;&#x9;&#x9;&#x9;state1_onDataTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;return stateById.get(1); // Folgezustand&#xA;&#x9;&#x9;&#x9;}">
              <condition xsi:type="dbl:InstanceOf" concreteSyntax="event instanceof Data">
                <op1 xsi:type="dbl:IdExpr" concreteSyntax="event" referencedElement="//@module/@classifiers.1/@methods.7/@statements.9/@trueCase/@statements.0"/>
                <op2 xsi:type="dbl:TypeAccess" concreteSyntax="Data">
                  <idExpr concreteSyntax="Data" referencedElement="//@module/@classifiers.0"/>
                </op2>
              </condition>
              <trueCase xsi:type="dbl:LocalScopeStatement" concreteSyntax="{&#xA;&#x9;&#x9;&#x9;&#x9;message = event;&#xA;&#x9;&#x9;&#x9;&#x9;state1_onDataTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;return stateById.get(1); // Folgezustand&#xA;&#x9;&#x9;&#x9;}">
                <statements xsi:type="dbl:Assignment" concreteSyntax="message = event">
                  <variable concreteSyntax="message">
                    <idExpr concreteSyntax="message" referencedElement="//@module/@classifiers.1/@attributes.8"/>
                  </variable>
                  <value xsi:type="dbl:IdExpr" concreteSyntax="event" referencedElement="//@module/@classifiers.1/@methods.7/@statements.9/@trueCase/@statements.0"/>
                </statements>
                <statements xsi:type="dbl:FunctionCall" concreteSyntax="state1_onDataTransition_effects()">
                  <callIdExpr concreteSyntax="state1_onDataTransition_effects()" referencedElement="//@module/@classifiers.1/@methods.8">
                    <callPart/>
                  </callIdExpr>
                </statements>
                <statements xsi:type="dbl:Return" concreteSyntax="return stateById.get(1)">
                  <value xsi:type="dbl:IdExpr" concreteSyntax="stateById.get(1)">
                    <parentIdExpr concreteSyntax="stateById" referencedElement="//@module/@classifiers.1/@attributes.4"/>
                    <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.7/@methods.0"/>
                    <callPart>
                      <callArguments xsi:type="dbl:IntLiteral" concreteSyntax="1" value="1"/>
                    </callPart>
                  </value>
                </statements>
              </trueCase>
            </statements>
            <statements xsi:type="dbl:IfStatement" concreteSyntax="if (event instanceof TimeEvent) {&#xA;&#x9;&#x9;&#x9;&#x9;TimeEvent timeEvent = event as TimeEvent;&#xA;&#x9;&#x9;&#x9;&#x9;if (timeEvent.associatedTransitionId == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;state1_afterTimeTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return stateById.get(1);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}">
              <condition xsi:type="dbl:InstanceOf" concreteSyntax="event instanceof TimeEvent">
                <op1 xsi:type="dbl:IdExpr" concreteSyntax="event" referencedElement="//@module/@classifiers.1/@methods.7/@statements.9/@trueCase/@statements.0"/>
                <op2 xsi:type="dbl:TypeAccess" concreteSyntax="TimeEvent">
                  <idExpr concreteSyntax="TimeEvent">
                    <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.6"/>
                  </idExpr>
                </op2>
              </condition>
              <trueCase xsi:type="dbl:LocalScopeStatement" concreteSyntax="{&#xA;&#x9;&#x9;&#x9;&#x9;TimeEvent timeEvent = event as TimeEvent;&#xA;&#x9;&#x9;&#x9;&#x9;if (timeEvent.associatedTransitionId == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;state1_afterTimeTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return stateById.get(1);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}">
                <statements xsi:type="dbl:Variable" name="timeEvent" concreteSyntax="TimeEvent timeEvent = event as TimeEvent">
                  <classifierType concreteSyntax="TimeEvent">
                    <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.6"/>
                  </classifierType>
                  <initialValue xsi:type="dbl:Cast" concreteSyntax="event as TimeEvent">
                    <classifierType concreteSyntax="TimeEvent">
                      <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.6"/>
                    </classifierType>
                    <op xsi:type="dbl:IdExpr" concreteSyntax="event" referencedElement="//@module/@classifiers.1/@methods.7/@statements.9/@trueCase/@statements.0"/>
                  </initialValue>
                </statements>
                <statements xsi:type="dbl:IfStatement" concreteSyntax="if (timeEvent.associatedTransitionId == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;state1_afterTimeTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return stateById.get(1);&#xA;&#x9;&#x9;&#x9;&#x9;}">
                  <condition xsi:type="dbl:Equal" concreteSyntax="timeEvent.associatedTransitionId == 0">
                    <op1 xsi:type="dbl:IdExpr" concreteSyntax="timeEvent.associatedTransitionId">
                      <parentIdExpr concreteSyntax="timeEvent" referencedElement="//@module/@classifiers.1/@methods.7/@statements.9/@trueCase/@statements.2/@trueCase/@statements.0"/>
                      <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.6/@attributes.0"/>
                    </op1>
                    <op2 xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
                  </condition>
                  <trueCase xsi:type="dbl:LocalScopeStatement" concreteSyntax="{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;state1_afterTimeTransition_effects();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return stateById.get(1);&#xA;&#x9;&#x9;&#x9;&#x9;}">
                    <statements xsi:type="dbl:FunctionCall" concreteSyntax="state1_afterTimeTransition_effects()">
                      <callIdExpr concreteSyntax="state1_afterTimeTransition_effects()" referencedElement="//@module/@classifiers.1/@methods.9">
                        <callPart/>
                      </callIdExpr>
                    </statements>
                    <statements xsi:type="dbl:Return" concreteSyntax="return stateById.get(1)">
                      <value xsi:type="dbl:IdExpr" concreteSyntax="stateById.get(1)">
                        <parentIdExpr concreteSyntax="stateById" referencedElement="//@module/@classifiers.1/@attributes.4"/>
                        <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.7/@methods.0"/>
                        <callPart>
                          <callArguments xsi:type="dbl:IntLiteral" concreteSyntax="1" value="1"/>
                        </callPart>
                      </value>
                    </statements>
                  </trueCase>
                </statements>
              </trueCase>
            </statements>
          </trueCase>
        </statements>
        <statements xsi:type="dbl:IfStatement" concreteSyntax="if (dataConsumer == null) {&#xA;&#x9;&#x9;&#x9;return stateById.get(0);&#xA;&#x9;&#x9;}">
          <condition xsi:type="dbl:Equal" concreteSyntax="dataConsumer == null">
            <op1 xsi:type="dbl:IdExpr" concreteSyntax="dataConsumer" referencedElement="//@module/@classifiers.1/@attributes.0"/>
            <op2 xsi:type="dbl:NullLiteral" concreteSyntax="null"/>
          </condition>
          <trueCase xsi:type="dbl:LocalScopeStatement" concreteSyntax="{&#xA;&#x9;&#x9;&#x9;return stateById.get(0);&#xA;&#x9;&#x9;}">
            <statements xsi:type="dbl:Return" concreteSyntax="return stateById.get(0)">
              <value xsi:type="dbl:IdExpr" concreteSyntax="stateById.get(0)">
                <parentIdExpr concreteSyntax="stateById" referencedElement="//@module/@classifiers.1/@attributes.4"/>
                <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.7/@methods.0"/>
                <callPart>
                  <callArguments xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
                </callPart>
              </value>
            </statements>
          </trueCase>
        </statements>
        <statements xsi:type="dbl:Return" concreteSyntax="return null">
          <value xsi:type="dbl:NullLiteral" concreteSyntax="null"/>
        </statements>
      </methods>
      <methods name="state1_onDataTransition_effects">
        <primitiveType xsi:type="dbl:VoidType"/>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="saveAsLastData(message as Data)">
          <callIdExpr concreteSyntax="saveAsLastData(message as Data)" referencedElement="//@module/@classifiers.1/@methods.10">
            <callPart>
              <callArguments xsi:type="dbl:Cast" concreteSyntax="message as Data">
                <classifierType concreteSyntax="Data" referencedElement="//@module/@classifiers.0"/>
                <op xsi:type="dbl:IdExpr" concreteSyntax="message" referencedElement="//@module/@classifiers.1/@attributes.8"/>
              </callArguments>
            </callPart>
          </callIdExpr>
        </statements>
      </methods>
      <methods name="state1_afterTimeTransition_effects">
        <primitiveType xsi:type="dbl:VoidType"/>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="forwardLastData()">
          <callIdExpr concreteSyntax="forwardLastData()" referencedElement="//@module/@classifiers.1/@methods.11">
            <callPart/>
          </callIdExpr>
        </statements>
      </methods>
      <methods name="saveAsLastData">
        <primitiveType xsi:type="dbl:VoidType"/>
        <statements xsi:type="dbl:Print" concreteSyntax="print &quot;received data with pay load: &quot; + data.payLoad">
          <outputs xsi:type="dbl:Plus" concreteSyntax="&quot;received data with pay load: &quot; + data.payLoad">
            <op1 xsi:type="dbl:StringLiteral" concreteSyntax="&quot;received data with pay load: &quot;" value="received data with pay load: "/>
            <op2 xsi:type="dbl:IdExpr" concreteSyntax="data.payLoad" referencedElement="//@module/@classifiers.0/@attributes.0">
              <parentIdExpr concreteSyntax="data" referencedElement="//@module/@classifiers.1/@methods.10/@parameters.0"/>
            </op2>
          </outputs>
        </statements>
        <statements xsi:type="dbl:Assignment" concreteSyntax="lastData = data">
          <variable concreteSyntax="lastData">
            <idExpr concreteSyntax="lastData" referencedElement="//@module/@classifiers.1/@attributes.1"/>
          </variable>
          <value xsi:type="dbl:IdExpr" concreteSyntax="data" referencedElement="//@module/@classifiers.1/@methods.10/@parameters.0"/>
        </statements>
        <parameters name="data">
          <classifierType concreteSyntax="Data" referencedElement="//@module/@classifiers.0"/>
        </parameters>
      </methods>
      <methods name="forwardLastData">
        <primitiveType xsi:type="dbl:VoidType"/>
        <statements xsi:type="dbl:Print" concreteSyntax="print &quot;sending data with pay load: &quot; + lastData.payLoad">
          <outputs xsi:type="dbl:Plus" concreteSyntax="&quot;sending data with pay load: &quot; + lastData.payLoad">
            <op1 xsi:type="dbl:StringLiteral" concreteSyntax="&quot;sending data with pay load: &quot;" value="sending data with pay load: "/>
            <op2 xsi:type="dbl:IdExpr" concreteSyntax="lastData.payLoad" referencedElement="//@module/@classifiers.0/@attributes.0">
              <parentIdExpr concreteSyntax="lastData" referencedElement="//@module/@classifiers.1/@attributes.1"/>
            </op2>
          </outputs>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="dataConsumer.sendSignal(lastData)">
          <callIdExpr concreteSyntax="dataConsumer.sendSignal(lastData)">
            <parentIdExpr concreteSyntax="dataConsumer" referencedElement="//@module/@classifiers.1/@attributes.0"/>
            <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.3/@methods.0"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="lastData" referencedElement="//@module/@classifiers.1/@attributes.1"/>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:Assignment" concreteSyntax="lastData = null">
          <variable concreteSyntax="lastData">
            <idExpr concreteSyntax="lastData" referencedElement="//@module/@classifiers.1/@attributes.1"/>
          </variable>
          <value xsi:type="dbl:NullLiteral" concreteSyntax="null"/>
        </statements>
      </methods>
      <actionsBlock>
        <statements xsi:type="dbl:Variable" name="disconnected" concreteSyntax="State disconnected = new State">
          <classifierType concreteSyntax="State">
            <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4"/>
          </classifierType>
          <initialValue xsi:type="dbl:CreateObject" concreteSyntax="new State">
            <classifierType concreteSyntax="State">
              <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4"/>
            </classifierType>
          </initialValue>
        </statements>
        <statements xsi:type="dbl:Assignment" concreteSyntax="disconnected.id = 0">
          <variable concreteSyntax="disconnected.id">
            <idExpr concreteSyntax="disconnected.id">
              <parentIdExpr concreteSyntax="disconnected" referencedElement="//@module/@classifiers.1/@actionsBlock/@statements.0"/>
              <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4/@attributes.0"/>
            </idExpr>
          </variable>
          <value xsi:type="dbl:IntLiteral" concreteSyntax="0"/>
        </statements>
        <statements xsi:type="dbl:Assignment" concreteSyntax="disconnected.name = &quot;disconnected&quot;">
          <variable concreteSyntax="disconnected.name">
            <idExpr concreteSyntax="disconnected.name">
              <parentIdExpr concreteSyntax="disconnected" referencedElement="//@module/@classifiers.1/@actionsBlock/@statements.0"/>
              <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4/@attributes.1"/>
            </idExpr>
          </variable>
          <value xsi:type="dbl:StringLiteral" concreteSyntax="&quot;disconnected&quot;" value="disconnected"/>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="stateById.put(disconnected.id, disconnected)">
          <callIdExpr concreteSyntax="stateById.put(disconnected.id, disconnected)">
            <parentIdExpr concreteSyntax="stateById" referencedElement="//@module/@classifiers.1/@attributes.4"/>
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.7/@methods.1"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="disconnected.id">
                <parentIdExpr concreteSyntax="disconnected" referencedElement="//@module/@classifiers.1/@actionsBlock/@statements.0"/>
                <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4/@attributes.0"/>
              </callArguments>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="disconnected" referencedElement="//@module/@classifiers.1/@actionsBlock/@statements.0"/>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:Assignment" concreteSyntax="currentState = disconnected">
          <variable concreteSyntax="currentState">
            <idExpr concreteSyntax="currentState" referencedElement="//@module/@classifiers.1/@attributes.5"/>
          </variable>
          <value xsi:type="dbl:IdExpr" concreteSyntax="disconnected" referencedElement="//@module/@classifiers.1/@actionsBlock/@statements.0"/>
        </statements>
        <statements xsi:type="dbl:Variable" name="waiting" concreteSyntax="State waiting = new State">
          <classifierType concreteSyntax="State">
            <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4"/>
          </classifierType>
          <initialValue xsi:type="dbl:CreateObject" concreteSyntax="new State">
            <classifierType concreteSyntax="State">
              <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4"/>
            </classifierType>
          </initialValue>
        </statements>
        <statements xsi:type="dbl:Assignment" concreteSyntax="waiting.id = 1">
          <variable concreteSyntax="waiting.id">
            <idExpr concreteSyntax="waiting.id">
              <parentIdExpr concreteSyntax="waiting" referencedElement="//@module/@classifiers.1/@actionsBlock/@statements.5"/>
              <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4/@attributes.0"/>
            </idExpr>
          </variable>
          <value xsi:type="dbl:IntLiteral" concreteSyntax="1" value="1"/>
        </statements>
        <statements xsi:type="dbl:Assignment" concreteSyntax="waiting.name = &quot;waiting&quot;">
          <variable concreteSyntax="waiting.name">
            <idExpr concreteSyntax="waiting.name">
              <parentIdExpr concreteSyntax="waiting" referencedElement="//@module/@classifiers.1/@actionsBlock/@statements.5"/>
              <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4/@attributes.1"/>
            </idExpr>
          </variable>
          <value xsi:type="dbl:StringLiteral" concreteSyntax="&quot;waiting&quot;" value="waiting"/>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="stateById.put(waiting.id, waiting)">
          <callIdExpr concreteSyntax="stateById.put(waiting.id, waiting)">
            <parentIdExpr concreteSyntax="stateById" referencedElement="//@module/@classifiers.1/@attributes.4"/>
            <referencedElement href="../../../stdlib.xmi#//@module/@classifiers.7/@methods.1"/>
            <callPart>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="waiting.id">
                <parentIdExpr concreteSyntax="waiting" referencedElement="//@module/@classifiers.1/@actionsBlock/@statements.5"/>
                <referencedElement href="../ssm-runtime.xmi#//@module/@classifiers.4/@attributes.0"/>
              </callArguments>
              <callArguments xsi:type="dbl:IdExpr" concreteSyntax="waiting" referencedElement="//@module/@classifiers.1/@actionsBlock/@statements.5"/>
            </callPart>
          </callIdExpr>
        </statements>
        <statements xsi:type="dbl:FunctionCall" concreteSyntax="eventLoop()">
          <callIdExpr concreteSyntax="eventLoop()" referencedElement="//@module/@classifiers.1/@methods.3">
            <callPart/>
          </callIdExpr>
        </statements>
      </actionsBlock>
    </classifiers>
    <functions name="main">
      <primitiveType xsi:type="dbl:VoidType"/>
      <statements xsi:type="dbl:Variable" name="delayer" concreteSyntax="Delayer delayer = new Delayer">
        <classifierType concreteSyntax="Delayer" referencedElement="//@module/@classifiers.1"/>
        <initialValue xsi:type="dbl:CreateObject" concreteSyntax="new Delayer">
          <classifierType concreteSyntax="Delayer" referencedElement="//@module/@classifiers.1"/>
        </initialValue>
      </statements>
      <statements xsi:type="dbl:ActivateObject" concreteSyntax="activate delayer">
        <objectAccess xsi:type="dbl:IdExpr" concreteSyntax="delayer" referencedElement="//@module/@functions.0/@statements.0"/>
      </statements>
      <statements xsi:type="dbl:Advance" concreteSyntax="advance 1">
        <time xsi:type="dbl:IntLiteral" concreteSyntax="1" value="1"/>
      </statements>
      <statements xsi:type="dbl:FunctionCall" concreteSyntax="delayer.sendSignal(new Data(&quot;blob&quot;))">
        <callIdExpr concreteSyntax="delayer.sendSignal(new Data(&quot;blob&quot;))" referencedElement="//@module/@classifiers.1/@methods.0">
          <parentIdExpr concreteSyntax="delayer" referencedElement="//@module/@functions.0/@statements.0"/>
          <callPart>
            <callArguments xsi:type="dbl:CreateObject" concreteSyntax="new Data(&quot;blob&quot;)">
              <classifierType concreteSyntax="Data(&quot;blob&quot;)" referencedElement="//@module/@classifiers.0">
                <callPart>
                  <callArguments xsi:type="dbl:StringLiteral" concreteSyntax="&quot;blob&quot;" value="blob"/>
                </callPart>
              </classifierType>
            </callArguments>
          </callPart>
        </callIdExpr>
      </statements>
      <statements xsi:type="dbl:Advance" concreteSyntax="advance 10">
        <time xsi:type="dbl:IntLiteral" concreteSyntax="10" value="10"/>
      </statements>
    </functions>
  </module>
</dbl:Model>
