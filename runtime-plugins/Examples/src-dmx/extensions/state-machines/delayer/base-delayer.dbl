#import "../ssm-runtime"
#import "../../stdlib"

module baseDelayerSystem;

class Data extends Signal {
	string payLoad;
	
	new(string payLoad) {
		self.payLoad = payLoad;
	}
}

void main() {
	Producer producer = new Producer;
	Delayer delayer = new Delayer;
	Consumer consumer = new Consumer;

	activate producer;
	activate delayer;
	activate consumer;

	advance 10;
	producer.receiver = delayer;
	delayer.receiver = consumer;	
}

active class Producer extends ObjectWithStateMachine {
	ObjectWithStateMachine receiver;
	
	actions {
		print "sending data to delayer";
		advance 1;
		receiver.sendSignal(new Data);
		advance 2;
		receiver.sendSignal(new Data);
	}
}

active class Consumer extends ObjectWithStateMachine {
}

active class Delayer extends ObjectWithStateMachine {
	control ObjectWithStateMachine receiver;
	Data lastReceived = null;
	
	// GENERATED from extension
	actions {
		stateMachineRuntime = createDelayerStateMachineRuntime();
		activate stateMachineRuntime;
	}
	
	void saveAsLastData(Data data) {
		print "received data with pay load: " + data.payLoad;
		lastReceived = data;
	}
	
	void forwardLastData() {
		print "sending data with pay load: " + lastReceived.payLoad;
		receiver.sendSignal(lastReceived);
		lastReceived = null;
	}
	
	void createStateMachineRuntime() {
	}
	
	void waitForEvent() {
		if (stateMachineRuntime.currentState.name.equals("waiting")) {
			waiting_waitForEvent(stateMachineRuntime.currentState.outgoingTransitions);
		}
	}
	
	Transition waiting_waitForEvent(Map transitions) {
		wait until stateMachineRuntime.eventQueue.size > 0 or receiver == null;
		if (receiver == null) {
			return transitions.get("WhenReceiverIsNullTransition");
		}
	}
}

// GENERATED from extension
class OnDataTransition extends CompiledTransition {
	boolean canHandleSignal(Event signal) {
		return signal instanceof Data; 
	}
	
	void executeEffects(Object context, Object event) {
		Delayer concreteContext = context as Delayer;
		concreteContext.saveAsLastData(event as Data);
	}
}

// GENERATED from extension
class After5Transition extends CompiledTransition {
	void executeEffects(Object context, Object event) {
		Delayer concreteContext = context as Delayer;
		concreteContext.forwardLastData();
	}
}

// GENERATED from extension
StateMachineRuntime createDelayerStateMachineRuntime() {
	StateMachine stateMachine = new StateMachine;
	StateMachineRuntime stateMachineRuntime = new StateMachineRuntime(stateMachine);

	// state waiting
	State waiting = new State;
	stateMachine.states.add(waiting);
	waiting.name = "waiting";
	
	CompiledState compiledWaiting = new CompiledState(waiting);
	stateMachineRuntime.setCompiledState(waiting, compiledWaiting);
	
	// transition on Data
	Transition onData = new Transition;
	waiting.outgoingTransitions.add(onData);
	onData.target = waiting;
	
	compiledWaiting.addCompiledTransition(new OnDataTransition(onData));	
	
	// transition after 5
	Transition after5 = new Transition;
	waiting.outgoingTransitions.add(after5);
	after5.target = waiting;
	
	CompiledTransition after5Compiled = new After5Transition(after5);
	compiledWaiting.addCompiledTransition(after5Compiled);
	
	Timer after5Timer = new Timer;
	after5Timer.stateMachineRuntime = stateMachineRuntime;
	after5Timer.compiledTransition = after5Compiled;
	compiledWaiting.addTimer(after5Timer);
	
	return stateMachineRuntime;
}